<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>rbczmq - binding for the high level ZeroMQ C API</title>

  <link type="text/css" media="screen" href="rdoc.css" rel="stylesheet" />

  <script src="js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body class="indexpage">

  
  <h1>rbczmq - binding for the high level ZeroMQ C API</h1>

  
  <div id="main">
    

<p>© 2011 Lourens Naudé (methodmissing), James Tucker (raggi) with API
guidance from the czmq (<a
href="http://czmq.zeromq.org/">czmq.zeromq.org/</a>) project.</p>

<pre>http://github.com/methodmissing/rbczmq</pre>

<h4>NOT YET PRODUCTION READY, BUT ALMOST</h4>

<h2>About ZeroMQ</h2>

<p>In a nutshell, ZeroMQ is a hybrid networking library / concurrency
framework. I quote the ØMQ Guide (<a
href="http://zguide.zeromq.org/page:all">zguide.zeromq.org/page:all</a>) :</p>

<p>“ØMQ (ZeroMQ, 0MQ, zmq) looks like an embeddable networking library but
acts like a concurrency framework. It gives you sockets that carry whole
messages across various transports like in-process, inter-process, TCP, and
multicast. You can connect sockets N-to-N with patterns like fanout,
pub-sub, task distribution, and request-reply. It’s fast enough to be the
fabric for clustered products. Its asynchronous I/O model gives you
scalable multicore applications, built as asynchronous message-processing
tasks. It has a score of language APIs and runs on most operating systems.
ØMQ is from iMatix and is LGPL open source.”</p>

<h2>Another ZeroMQ extension ?</h2>

<p>This extension bundles both ZeroMQ (libzmq, <a
href="http://www.zeromq.org/">www.zeromq.org/</a>) and CZMQ (libczmq, <a
href="http://czmq.zeromq.org/">czmq.zeromq.org/</a>) and as such have no
third party dependencies other than a Ruby distribution and a C compiler.
My goals for this project were :</p>
<ul><li>
<p>Access to a powerful messaging technology without having to install a bunch
of dependencies</p>
</li><li>
<p>A stable and mostly version agnostic (2.x and 3.x series) API</p>
</li><li>
<p>Leverage and build upon a mature and maintained client (CZMQ)</p>
</li><li>
<p>Target Ruby distributions with a stable and comprehensive C API (MRI,
Rubinius, JRuby is work in progress)</p>
</li><li>
<p>Support for running sockets in Threads - both green and native threads
should be supported and preempt properly with edge-triggered multiplexing
from libzmq.</p>
</li><li>
<p>Integrate with the Garbage Collector in a predictable way. CZMQ and the
ZeroMQ framework is very fast and can allocate an enormous amount of
objects in no time when using the Frame, Message and String wrappers.
Resources such as socket connections should be cleaned up when objects are
finalized as well.</p>
</li><li>
<p>Expose Message envelopes and Frames to developers as well to allow for
higher level protocols and constructs.</p>
</li><li>
<p>Enforce well known best practices such as restricting socket interactions
to within the thread the socket was created in etc.</p>
</li></ul>

<h2>Performance</h2>

<p>ZeroMQ can have higher throughput than TCP in most cases by using a message
batching technique. Please have a look through the Performance section in
the ZeroMQ FAQ (<a
href="http://www.zeromq.org/area:faq#toc2">www.zeromq.org/area:faq#toc2</a>)
for further implementation details.</p>

<p>Some notes about these benchmarks :</p>
<ul><li>
<p>Messages go through the full network stack on localhost (TCP/IP transport)</p>
</li><li>
<p>The sender and receiver endpoints are Ruby processes which coerce
transferred data to native String objects on both ends.</p>
</li><li>
<p>There’s thus a definite method dispatch cost in addition to intermittent
pauses from the Garbage Collector</p>
</li><li>
<p>It’s still plenty fast for most soft real-time applications and we’re able
to push in excess of 1 gigabits/s with the 1024 byte payloads. A language
with automatic memory management cannot easily comply to hard real-time
guarantees anyways.</p>
</li></ul>

<h3>TCP/IP loopback, 100k messages, 100 byte payloads</h3>

<pre>Lourenss-MacBook-Air:rbczmq lourens$ MSG_COUNT=100000 MSG_SIZE=100 ruby perf/pair.rb
Local pids: 2042
Remote pid: 2043
Sent 100000 messages in 0.3933s ...
[2043] Memory used before: 1128kb
[2043] Memory used after: 3012kb
[2042] Memory used before: 1120kb
====== [2042] transfer stats ======
message encoding: string
message size: 100 [B]
message count: 100000
mean throughput: 227978 [msg/s]
mean throughput: 182.383 [Mb/s]
[2042] Memory used after: 22432kb</pre>

<h3>TCP/IP loopback, 100k messages, 1024 byte payloads</h3>

<pre>Lourenss-MacBook-Air:rbczmq lourens$ MSG_COUNT=100000 MSG_SIZE=1024 ruby perf/pair.rb
Local pids: 2027
Remote pid: 2028
Sent 100000 messages in 0.641198s ...
[2028] Memory used before: 1120kb
[2028] Memory used after: 12776kb
[2027] Memory used before: 1144kb
====== [2027] transfer stats ======
message encoding: string
message size: 1024 [B]
message count: 100000
mean throughput: 160756 [msg/s]
mean throughput: 1316.919 [Mb/s]
[2027] Memory used after: 189004kb</pre>

<h3>TCP/IP loopback, 100k messages, 2048 byte payloads</h3>

<pre>Lourenss-MacBook-Air:rbczmq lourens$ MSG_COUNT=100000 MSG_SIZE=2048 ruby perf/pair.rb
Local pids: 2034
Remote pid: 2035
Sent 100000 messages in 0.94703s ...
[2035] Memory used before: 1140kb
[2035] Memory used after: 7212kb
[2034] Memory used before: 1128kb
====== [2034] transfer stats ======
message encoding: string
message size: 2048 [B]
message count: 100000
mean throughput: 123506 [msg/s]
mean throughput: 2023.528 [Mb/s]
[2034] Memory used after: 277712kb</pre>

<p>Have a play around with the performance runner and other socket pairs as
well - <a
href="https://github.com/methodmissing/rbczmq/tree/master/perf">github.com/methodmissing/rbczmq/tree/master/perf</a></p>

<h2>Usage</h2>

<p>As a first step I’d highly recommend you read (and reread) through the
zguide (<a
href="http://zguide.zeromq.org/page:all">zguide.zeromq.org/page:all</a>) as
understanding the supported messaging patterns and topologies is
fundamental to getting the most from this binding.  Here’s a few basic
examples. Please refer to documentation (<a
href="http://methodmissing.github.com/rbczmq/">methodmissing.github.com/rbczmq/</a>)
and test cases (<a
href="https://github.com/methodmissing/rbczmq/tree/master/test">github.com/methodmissing/rbczmq/tree/master/test</a>)
for detailed usage information.</p>

<h3>Basic send / receive, in process transport</h3>

<pre>ctx = ZMQ::Context.new
rep = ctx.socket(:PAIR)
port = rep.bind(&quot;inproc://send.receive&quot;)
req = ctx.socket(:PAIR)
req.connect(&quot;inproc://send.receive&quot;)
req.send(&quot;ping&quot;) # true
rep.recv # &quot;ping&quot;

ctx.destroy</pre>

<h3>Fair-queued work distribution to a set of worker threads</h3>

<pre>ctx = ZMQ::Context.new
push = ctx.bind(:PUSH, &quot;inproc://push-pull-distribution.test&quot;)
threads = []
5.times do
  threads &lt;&lt; Thread.new do
    pull = ctx.connect(:PULL, &quot;inproc://push-pull-distribution.test&quot;)
    msg = pull.recv
    pull.close
    msg
  end
end

sleep 0.5 # avoid &quot;slow joiner&quot; syndrome
messages = %w(a b c d e f)
messages.each do |m|
  push.send m
end

threads.each{|t| t.join }
threads.all?{|t| messages.include?(t.value) } # true

ctx.destroy</pre>

<h3>Async request / reply routing</h3>

<pre>ctx = ZMQ::Context.new
router = ctx.bind(:ROUTER, &quot;inproc://routing-flow.test&quot;)
dealer = ctx.socket(:DEALER)
dealer.identity = &quot;xyz&quot;
dealer.connect(&quot;inproc://routing-flow.test&quot;)

router.sendm(&quot;xyz&quot;)
router.send(&quot;request&quot;)
dealer.recv # &quot;request&quot;

dealer.send(&quot;reply&quot;)
router.recv # &quot;xyz&quot;
router.recv # &quot;reply&quot;

ctx.destroy</pre>

<h3>Send / receive frames</h3>

<pre>ctx = ZMQ::Context.new
rep = ctx.socket(:PAIR)
rep.bind(&quot;inproc://frames.test&quot;)
req = ctx.socket(:PAIR)
req.connect(&quot;inproc://frames.test&quot;)
ping = ZMQ::Frame(&quot;ping&quot;)
req.send_frame(ping) # true
rep.recv_frame # ZMQ::Frame(&quot;ping&quot;)
rep.send_frame(ZMQ::Frame(&quot;pong&quot;)) # true
req.recv_frame # ZMQ::Frame(&quot;pong&quot;)
rep.send_frame(ZMQ::Frame(&quot;pong&quot;)) # true
req.recv_frame_nonblock # nil
sleep 0.3
req.recv_frame_nonblock # ZMQ::Frame(&quot;pong&quot;)

ctx.destroy</pre>

<h3>Send / receive messages</h3>

<pre>ctx = ZMQ::Context.new
rep = ctx.socket(:PAIR)
rep.bind(&quot;inproc://messages.test&quot;)
req = ctx.socket(:PAIR)
req.connect(&quot;inproc://messages.test&quot;)

msg = ZMQ::Message.new
msg.push ZMQ::Frame(&quot;header&quot;)
msg.push ZMQ::Frame(&quot;body&quot;)

req.send_message(msg) # nil

recvd_msg = rep.recv_message
recvd_msg.class # ZMQ::Message
recvd_msg.pop # ZMQ::Frame(&quot;header&quot;)
recvd_msg.pop # ZMQ::Frame(&quot;body&quot;)

ctx.destroy</pre>

<h2>Resources</h2>
<ul><li>
<p>ZeroMQ - <a
href="http://www.zeromq.org/community">www.zeromq.org/community</a></p>
</li><li>
<p>The ØMQ Reference Manual - <a
href="http://api.zeromq.org/">api.zeromq.org/</a></p>
</li><li>
<p>The ØMQ FAQ - <a
href="http://www.zeromq.org/area:faq">www.zeromq.org/area:faq</a></p>
</li><li>
<p>Whitepapers - <a
href="http://www.zeromq.org/area:whitepapers">www.zeromq.org/area:whitepapers</a></p>
</li><li>
<p>The ØMQ Guide - <a
href="http://zguide.zeromq.org/page:all">zguide.zeromq.org/page:all</a></p>
</li><li>
<p>CZMQ - <a href="http://czmq.zeromq.org/">czmq.zeromq.org/</a></p>
</li><li>
<p>Recent presentation on data transfer by the author of this binding - <a
href="http://www.slideshare.net/methodmissing/sapo-codebits-2011">www.slideshare.net/methodmissing/sapo-codebits-2011</a></p>
</li></ul>

<h2>Requirements</h2>
<ul><li>
<p>A POSIX compliant OS, known to work well on Linux, BSD variants and Mac OS
X</p>
</li><li>
<p>Ruby MRI 1.8, 1.9 or Rubinius (JRuby capi support forthcoming)</p>
</li><li>
<p>A C compiler</p>
</li></ul>

<h2>Installation</h2>

<p>Rubygems installation</p>

<pre>gem install rbczmq</pre>

<p>Building from source</p>

<pre>git clone git@github.com:methodmissing/rbczmq.git
rake</pre>

<p>Running tests</p>

<pre>rake test</pre>

<h2>TODO</h2>
<ul><li>
<p>ZMQ::Message#save &amp;&amp; ZMQ::Message.load</p>
</li><li>
<p>ZMQ::Socket#handler = x. Assert handler interface here instead ???</p>
</li><li>
<p>Callback handler for <a href="ZMQ/Socket.html">ZMQ::Socket</a> useful
beyond just <a href="ZMQ/Loop.html">ZMQ::Loop</a> ?</p>
</li><li>
<p>Optimize zloop handler callbacks (perftools)</p>
</li><li>
<p>OS X leaks utility - <a
href="http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/leaks.1.html">developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/leaks.1.html</a></p>
</li><li>
<p>Handle GC issue with timers in loop callbacks</p>
</li><li>
<p>czmq send methods aren’t non-blocking by default</p>
</li><li>
<p>Enforce socket timeouts</p>
</li><li>
<p>Look into handling signals properly</p>
</li><li>
<p>Revisit the <a href="ZMQ/Loop.html">ZMQ::Loop</a> API</p>
</li><li>
<p>Restrict pair sockets to inproc transport only</p>
</li><li>
<p>Revisit JRuby C API support</p>
</li><li>
<p>Push gem out to rubygems.org</p>
</li><li>
<p>RDOC fail on mixed C and Ruby source files that document that same
constants</p>
</li><li>
<p>GC guards to prevent recycling objects being sent / received.</p>
</li><li>
<p>Sockets can bind &amp;&amp; connect to multiple endpoints - account for
that</p>
</li><li>
<p>Try to catch socket setup that’ll have the context ripped out by the GC eg.
ZMQ::Context.new.socket(:PUSH)</p>
</li><li>
<p>Watch out for further cases where REQ / REP pairs could raise EFSM</p>
</li><li>
<p>Fix Rubinius linking wrong libzmq</p>
</li><li>
<p>Regen gh-pages branch to reflect <a href="ZMQ/Poller.html">ZMQ::Poller</a>
changes</p>
</li><li>
<p>Do not clobber local scope from macros (James’s commit in master)</p>
</li><li>
<p>Let <a href="ZMQ/Pollitem.html">ZMQ::Pollitem</a> support BasicSocket as
well</p>
</li><li>
<p>Verbose mode for <a href="ZMQ/Poller.html">ZMQ::Poller</a> and let <a
href="ZMQ/Pollitem.html">ZMQ::Pollitem</a> be aware of verbose pollables as
well</p>
</li><li>
<p>Handle examples/../lib/zmq/loop.rb:69: [BUG] Segmentation fault</p>
</li><li>
<p>Support installation without vendor’ed libs as well</p>
</li><li>
<p>Incorporate examples into CI as well</p>
</li></ul>

<h2>Contact, feedback and bugs</h2>

<p>This project is still work in progress and I’m looking for guidance on API
design, use cases and any outlier experiences. Please log bugs and
suggestions at <a
href="https://github.com/methodmissing/rbczmq/issues">github.com/methodmissing/rbczmq/issues</a></p>

  </div>
  

  
  
  <h2>Files</h2>
  <ul>
    
      <li class="file"><a href="README_rdoc.html">README.rdoc</a></li>
    
  </ul>
  

  <h2 id="classes">Classes/Modules</h2>
  <ul>
    
    <li class="module"><a href="ZMQ.html">ZMQ</a></li>
    
    <li class="class"><a href="ZMQ/Context.html">ZMQ::Context</a></li>
    
    <li class="class"><a href="ZMQ/DefaultHandler.html">ZMQ::DefaultHandler</a></li>
    
    <li class="module"><a href="ZMQ/DownstreamSocket.html">ZMQ::DownstreamSocket</a></li>
    
    <li class="class"><a href="ZMQ/Error.html">ZMQ::Error</a></li>
    
    <li class="class"><a href="ZMQ/Frame.html">ZMQ::Frame</a></li>
    
    <li class="class"><a href="ZMQ/Handler.html">ZMQ::Handler</a></li>
    
    <li class="class"><a href="ZMQ/Loop.html">ZMQ::Loop</a></li>
    
    <li class="class"><a href="ZMQ/Loop.html">ZMQ::Loop</a></li>
    
    <li class="class"><a href="ZMQ/Message.html">ZMQ::Message</a></li>
    
    <li class="class"><a href="ZMQ/Poller.html">ZMQ::Poller</a></li>
    
    <li class="class"><a href="ZMQ/Pollitem.html">ZMQ::Pollitem</a></li>
    
    <li class="class"><a href="ZMQ/Socket.html">ZMQ::Socket</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Dealer.html">ZMQ::Socket::Dealer</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Pair.html">ZMQ::Socket::Pair</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Pub.html">ZMQ::Socket::Pub</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Pull.html">ZMQ::Socket::Pull</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Push.html">ZMQ::Socket::Push</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Rep.html">ZMQ::Socket::Rep</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Req.html">ZMQ::Socket::Req</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Router.html">ZMQ::Socket::Router</a></li>
    
    <li class="class"><a href="ZMQ/Socket/Sub.html">ZMQ::Socket::Sub</a></li>
    
    <li class="class"><a href="ZMQ/Timer.html">ZMQ::Timer</a></li>
    
    <li class="module"><a href="ZMQ/UpstreamSocket.html">ZMQ::UpstreamSocket</a></li>
    
    <li class="class"><a href="Object.html">Object</a></li>
    
    <li class="class"><a href="ZMQ/Loop.html">Object::ZL</a></li>
    
  </ul>

  <h2 id="methods">Methods</h2>
  <ul>
    
      <li><a href="ZMQ.html#method-c-Frame">::Frame &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ.html#method-c-Message">::Message &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ.html#method-c-Pollitem">::Pollitem &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_oneshot_timer">::add_oneshot_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_oneshot_timer">::add_oneshot_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_oneshot_timer">::add_oneshot_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_periodic_timer">::add_periodic_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_periodic_timer">::add_periodic_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_periodic_timer">::add_periodic_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_timer">::add_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_timer">::add_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-add_timer">::add_timer &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-bind">::bind &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-bind">::bind &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-bind">::bind &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-connect">::connect &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-connect">::connect &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-connect">::connect &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ.html#method-c-context">::context &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ.html#method-c-error">::error &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ/Socket.html#method-c-handle_fsm_errors">::handle_fsm_errors &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/UpstreamSocket.html#method-c-included">::included &mdash; ZMQ::UpstreamSocket</a></li>
    
      <li><a href="ZMQ/DownstreamSocket.html#method-c-included">::included &mdash; ZMQ::DownstreamSocket</a></li>
    
      <li><a href="ZMQ.html#method-c-interrupted-3F">::interrupted? &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ.html#method-c-log">::log &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ.html#method-c-loop">::loop &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ/Timer.html#method-c-new">::new &mdash; ZMQ::Timer</a></li>
    
      <li><a href="ZMQ/Handler.html#method-c-new">::new &mdash; ZMQ::Handler</a></li>
    
      <li><a href="ZMQ.html#method-c-now">::now &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-register_readable">::register_readable &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-register_readable">::register_readable &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-register_readable">::register_readable &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-register_writable">::register_writable &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-register_writable">::register_writable &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-register_writable">::register_writable &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-run">::run &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-run">::run &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ/Loop.html#method-c-run">::run &mdash; ZMQ::Loop</a></li>
    
      <li><a href="ZMQ.html#method-c-select">::select &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ/Socket.html#method-c-unsupported_api">::unsupported_api &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ.html#method-c-version">::version &mdash; ZMQ</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-affinity">#affinity &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-affinity-3D">#affinity= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-backlog">#backlog &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-backlog-3D">#backlog= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Context.html#method-i-bind">#bind &mdash; ZMQ::Context</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-bind">#bind &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Timer.html#method-i-call">#call &mdash; ZMQ::Timer</a></li>
    
      <li><a href="ZMQ/Timer.html#method-i-cancel">#cancel &mdash; ZMQ::Timer</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-close">#close &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Context.html#method-i-connect">#connect &mdash; ZMQ::Context</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-connect">#connect &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-endpoint">#endpoint &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-events">#events &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-fd">#fd &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Timer.html#method-i-fire">#fire &mdash; ZMQ::Timer</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-hwm">#hwm &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-hwm-3D">#hwm= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-identity-3D">#identity= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-linger">#linger &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-linger-3D">#linger= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-mcast_loop-3D">#mcast_loop= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-mcast_loop-3F">#mcast_loop? &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Handler.html#method-i-on_error">#on_error &mdash; ZMQ::Handler</a></li>
    
      <li><a href="ZMQ/Timer.html#method-i-on_error">#on_error &mdash; ZMQ::Timer</a></li>
    
      <li><a href="ZMQ/DefaultHandler.html#method-i-on_readable">#on_readable &mdash; ZMQ::DefaultHandler</a></li>
    
      <li><a href="ZMQ/Handler.html#method-i-on_readable">#on_readable &mdash; ZMQ::Handler</a></li>
    
      <li><a href="ZMQ/DefaultHandler.html#method-i-on_writable">#on_writable &mdash; ZMQ::DefaultHandler</a></li>
    
      <li><a href="ZMQ/Handler.html#method-i-on_writable">#on_writable &mdash; ZMQ::Handler</a></li>
    
      <li><a href="ZMQ/Poller.html#method-i-poll_nonblock">#poll_nonblock &mdash; ZMQ::Poller</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-poll_readable-3F">#poll_readable? &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/UpstreamSocket.html#method-i-poll_readable-3F">#poll_readable? &mdash; ZMQ::UpstreamSocket</a></li>
    
      <li><a href="ZMQ/DownstreamSocket.html#method-i-poll_writable-3F">#poll_writable? &mdash; ZMQ::DownstreamSocket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-poll_writable-3F">#poll_writable? &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-rate">#rate &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-rate-3D">#rate= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-rcvbuf">#rcvbuf &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-rcvbuf-3D">#rcvbuf= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-rcvmore-3F">#rcvmore? &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-readable-3F">#readable? &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-reconnect_ivl">#reconnect_ivl &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-reconnect_ivl-3D">#reconnect_ivl= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-reconnect_ivl_max">#reconnect_ivl_max &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-reconnect_ivl_max-3D">#reconnect_ivl_max= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recovery_ivl">#recovery_ivl &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recovery_ivl-3D">#recovery_ivl= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recovery_ivl_msec">#recovery_ivl_msec &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recovery_ivl_msec-3D">#recovery_ivl_msec= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Pollitem.html#method-i-recv">#recv &mdash; ZMQ::Pollitem</a></li>
    
      <li><a href="ZMQ/Handler.html#method-i-recv">#recv &mdash; ZMQ::Handler</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv">#recv &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv_frame">#recv_frame &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv_frame_nonblock">#recv_frame_nonblock &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv_message">#recv_message &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv_nonblock">#recv_nonblock &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv_timeout">#recv_timeout &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-recv_timeout-3D">#recv_timeout= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Poller.html#method-i-register_readable">#register_readable &mdash; ZMQ::Poller</a></li>
    
      <li><a href="ZMQ/Poller.html#method-i-register_writable">#register_writable &mdash; ZMQ::Poller</a></li>
    
      <li><a href="ZMQ/Pollitem.html#method-i-send">#send &mdash; ZMQ::Pollitem</a></li>
    
      <li><a href="ZMQ/Handler.html#method-i-send">#send &mdash; ZMQ::Handler</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-send">#send &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket/Req.html#method-i-send_frame">#send_frame &mdash; ZMQ::Socket::Req</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-send_frame">#send_frame &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket/Rep.html#method-i-send_frame">#send_frame &mdash; ZMQ::Socket::Rep</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-send_message">#send_message &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-send_timeout">#send_timeout &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-send_timeout-3D">#send_timeout= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-sendm">#sendm &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-sndbuf">#sndbuf &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-sndbuf-3D">#sndbuf= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-state">#state &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-subscribe">#subscribe &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-swap">#swap &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-swap-3D">#swap= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-to_i">#to_i &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-to_s">#to_s &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket/Sub.html#method-i-type">#type &mdash; ZMQ::Socket::Sub</a></li>
    
      <li><a href="ZMQ/Socket/Pull.html#method-i-type">#type &mdash; ZMQ::Socket::Pull</a></li>
    
      <li><a href="ZMQ/Socket/Pub.html#method-i-type">#type &mdash; ZMQ::Socket::Pub</a></li>
    
      <li><a href="ZMQ/Socket/Pair.html#method-i-type">#type &mdash; ZMQ::Socket::Pair</a></li>
    
      <li><a href="ZMQ/Socket/Dealer.html#method-i-type">#type &mdash; ZMQ::Socket::Dealer</a></li>
    
      <li><a href="ZMQ/Socket/Push.html#method-i-type">#type &mdash; ZMQ::Socket::Push</a></li>
    
      <li><a href="ZMQ/Socket/Router.html#method-i-type">#type &mdash; ZMQ::Socket::Router</a></li>
    
      <li><a href="ZMQ/Socket/Rep.html#method-i-type">#type &mdash; ZMQ::Socket::Rep</a></li>
    
      <li><a href="ZMQ/Socket/Req.html#method-i-type">#type &mdash; ZMQ::Socket::Req</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-type_str">#type_str &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-unsubscribe">#unsubscribe &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-verbose-3D">#verbose= &mdash; ZMQ::Socket</a></li>
    
      <li><a href="ZMQ/Socket.html#method-i-writable-3F">#writable? &mdash; ZMQ::Socket</a></li>
    
  </ul>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>
</body>
</html>
